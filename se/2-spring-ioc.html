<!doctype html>
<html lang="th">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spring Framework Core: IoC, DI, AOP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reset.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/black.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Prompt:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Prompt', sans-serif; }
        .reveal .slides { text-align: left; }
        .reveal pre code { max-height: 600px; }
        .reveal table { width: 100%; border-collapse: collapse; text-align: left; }
        .reveal th, .reveal td { border: 1px solid #ddd; padding: 8px; }
        .reveal th { background-color: #333; color: white; }
        .reveal li { margin-bottom: 0.5em; }
        .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6, .reveal p, .reveal li, .reveal td, .reveal th { font-family: 'Prompt', sans-serif; }
    </style>
</head>
<body>
<div class="reveal">
<div class="slides">

<section>
    <h2>Spring Framework Core</h2>
    <p>ความเข้าใจใน IoC, DI, AOP</p>
</section>

<section>
    <h3>บทนำ Spring Framework</h3>
    <p>Spring Framework เป็นเฟรมเวิร์กสำหรับพัฒนาแอปพลิเคชัน Java ที่ช่วยให้โค้ดเป็นระบบและดูแลง่าย</p>
</section>

<section>
    <h3>หลักการสำคัญของ Spring</h3>
    <ul>
        <li>Inversion of Control (IoC)</li>
        <li>Dependency Injection (DI)</li>
        <li>Aspect-Oriented Programming (AOP)</li>
    </ul>
</section>

<section>
    <h3>Inversion of Control (IoC) คืออะไร?</h3>
    <p>IoC คือแนวคิดที่ให้ Framework เป็นผู้จัดการการสร้างและ lifecycle ของ object แทนที่เราจะสร้างเอง</p>
</section>

<section>
    <h3>ปัญหาแบบเดิม (Tight Coupling)</h3>
    <pre><code class="language-java">public class Car {
    private Engine engine = new Engine(); // สร้างเอง
}
</code></pre>
    <p>คลาส Car ผูกติดกับ Engine อย่างแน่น</p>
</section>

<section>
    <h3>แก้ปัญหาด้วย IoC</h3>
    <pre><code class="language-java">public class Car {
    private Engine engine;
    public Car(Engine engine) {
        this.engine = engine; // ได้จากภายนอก
    }
}
</code></pre>
    <p>คลาส Car ไม่ต้องสร้าง Engine เอง</p>
</section>

<section>
    <h3>IoC Container ใน Spring</h3>
    <ul>
        <li>BeanFactory: IoC container พื้นฐาน</li>
        <li>ApplicationContext: ใช้บ่อย มีฟีเจอร์เพิ่ม เช่น event, internationalization</li>
    </ul>
</section>

<section>
    <h3>Bean คืออะไร?</h3>
    <p>Bean คือ object ที่ถูกสร้างและจัดการโดย Spring IoC Container</p>
</section>

<section>
    <h3>การกำหนด Bean ด้วย Annotation</h3>
    <pre><code class="language-java">@Component
public class Engine {
    // ...
}
</code></pre>
    <p>@Component บอก Spring ให้สร้าง Bean ของคลาสนี้</p>
</section>

<section>
    <h3>Dependency Injection (DI) คืออะไร?</h3>
    <p>DI คือการ "ฉีด" dependencies เข้าไปใน object โดยไม่ต้องสร้างเอง</p>
</section>

<section>
    <h3>ประโยชน์ของ DI</h3>
    <ul>
        <li>ลดการผูกติด (Coupling) ระหว่างคลาส</li>
        <li>ทดสอบง่ายขึ้น (Testability)</li>
        <li>โค้ดดูแลง่าย (Maintainability)</li>
        <li>ยืดหยุ่นสูง (Flexibility)</li>
    </ul>
</section>

<section>
    <h3>DI แบบ Constructor Injection</h3>
    <pre><code class="language-java">@Component
public class Engine {}
@Component
public class Car {
    private Engine engine;
    public Car(Engine engine) {
        this.engine = engine;
    }
}
</code></pre>
    <p>Spring จะฉีด Engine เข้าไปใน Constructor ของ Car</p>
</section>

<section>
    <h3>DI แบบ Setter Injection</h3>
    <pre><code class="language-java">@Component
public class Car {
    private Engine engine;
    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}
</code></pre>
    <p>Spring จะเรียก setter method และฉีด Engine เข้าไป</p>
</section>

<section>
    <h3>DI แบบ Field Injection</h3>
    <pre><code class="language-java">@Component
public class Car {
    @Autowired
    private Engine engine;
}
</code></pre>
    <p>Spring จะฉีด Engine เข้าไปใน field โดยตรง</p>
</section>

<section>
    <h3>Scope ของ Bean ใน Spring</h3>
    <ul>
        <li>Singleton: สร้างแค่ 1 instance (default)</li>
        <li>Prototype: สร้างใหม่ทุกครั้งที่เรียก</li>
        <li>Request: 1 instance ต่อ HTTP request</li>
        <li>Session: 1 instance ต่อ HTTP session</li>
        <li>Application: 1 instance ต่อ ServletContext</li>
    </ul>
</section>

<section>
    <h3>Lifecycle ของ Bean</h3>
    <ul>
        <li>Instantiation: สร้าง object</li>
        <li>Populate properties: ตั้งค่า properties</li>
        <li>Set bean name: ตั้งชื่อ bean</li>
        <li>Set bean factory: ตั้ง bean factory</li>
        <li>Pre-initialization: เรียก BeanPostProcessor</li>
        <li>Initialization: เรียก @PostConstruct หรือ init-method</li>
        <li>Post-initialization: เรียก BeanPostProcessor</li>
        <li>Ready to use: พร้อมใช้งาน</li>
        <li>Destruction: เรียก @PreDestroy หรือ destroy-method</li>
    </ul>
</section>

<section>
    <h3>Aspect-Oriented Programming (AOP) คืออะไร?</h3>
    <p>AOP คือแนวคิดในการแยกโค้ดที่ "ตัดขวาง" เช่น log, security, transaction management ออกจาก business logic</p>
</section>

<section>
    <h3>ปัญหาแบบเดิม (Code Tangling)</h3>
    <pre><code class="language-java">public void processOrder() {
    log.info("Start");
    // business logic
    log.info("End");
}
</code></pre>
    <p>โค้ด log ปะปนกับ business logic ทำให้ดูแลยาก</p>
</section>

<section>
    <h3>แก้ปัญหาด้วย AOP</h3>
    <pre><code class="language-java">@Aspect
public class LoggingAspect {
    @Before("execution(* processOrder(..))")
    public void logStart() { log.info("Start"); }
    @After("execution(* processOrder(..))")
    public void logEnd() { log.info("End"); }
}
</code></pre>
    <p>โค้ด log ถูกแยกออกจาก business logic</p>
</section>

<section>
    <h3>องค์ประกอบของ AOP</h3>
    <ul>
        <li>Aspect: โมดูลที่รวมฟังก์ชันตัดขวาง</li>
        <li>Join Point: จุดที่ aspect สามารถแทรกโค้ดได้</li>
        <li>Advice: โค้ดที่ถูกแทรก (before, after, around)</li>
        <li>Pointcut: เงื่อนไขที่ระบุว่า advice จะถูกใช้เมื่อไหร่</li>
        <li>Target: object ที่ถูก aspect แทรก</li>
        <li>Proxy: object ที่ถูกสร้างขึ้นเพื่อแทน target</li>
    </ul>
</section>

<section>
    <h3>Annotation สำคัญใน AOP</h3>
    <ul>
        <li>@Aspect: ประกาศคลาสเป็น aspect</li>
        <li>@Before: เรียกก่อนเมธอด</li>
        <li>@After: เรียกหลังเมธอด</li>
        <li>@Around: ครอบเมธอดทั้งหมด</li>
        <li>@Pointcut: ระบุเงื่อนไข</li>
    </ul>
</section>

<section>
    <h3>ตัวอย่าง @Around Advice</h3>
    <pre><code class="language-java">@Aspect
public class PerformanceAspect {
    @Around("execution(* processOrder(..))")
    public Object measureTime(ProceedingJoinPoint pjp) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = pjp.proceed();
        long end = System.currentTimeMillis();
        System.out.println("Time: " + (end - start) + "ms");
        return result;
    }
}
</code></pre>
</section>

<section>
    <h3>Spring AOP vs Full AOP Framework</h3>
    <ul>
        <li>Spring AOP: ใช้ proxy-based, เหมาะกับ method-level</li>
        <li>Full AOP (AspectJ): รองรับ field-level, constructor-level</li>
    </ul>
</section>

<section>
    <h3>ตัวอย่างการใช้งานจริง</h3>
    <pre><code class="language-java">@Aspect
public class SecurityAspect {
    @Before("execution(* transfer(..))")
    public void checkPermission() {
        // ตรวจสอบสิทธิ์ก่อนโอนเงิน
    }
}
</code></pre>
</section>

<section>
    <h3>สรุป Spring Core</h3>
    <ul>
        <li>IoC: Framework จัดการ object lifecycle</li>
        <li>DI: ฉีด dependencies อัตโนมัติ</li>
        <li>AOP: แยก concerns ออกจาก business logic</li>
    </ul>
</section>

</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: []
    });
</script>
</body>
</html>
